<!DOCTYPE html>
<h1>絕世好武功</h1>

<pre>

純陽真氣              三圈圈方方三圈方方
灼心訣              方方三
玄火劫心功       三圈圈方方三
洗髓功              方三圈方方
羅漢伏魔功*      三三方方圈圈            *小世界嚴寒金剛寺
玄陰真氣             三方方圈方三圈圈三
玲瓏訣              圈圈三
寒冰訣              圈方三
清心訣              三方方圈方三
五覺功              圈方三圈圈三
毒煞真氣
奪魄功              方方圈三三
解蠱訣              圈三方三圈
避毒訣              方方三圈三
混元真氣             圈三方圈三方圈方三圈三三
醉意功              圈三三
醉仙訣              圈方三圈三三
混元一氣功       三方圈三方
易筋經              圈三方圈三方
共通心法
吐納法              圈三方
偷天換日功       圈三三方方
形意五禽功       三方圈方三
金針度穴功*     方圈方三圈三          *醫術小成(三級)
宗門心法
馭獸訣*            方圈方                     *宗主寶箱or藏寶圖
化龍功              圈方三方圈方
血煞吐納功       三三方圈三
搬血鍛體訣       三方三方三
玄龜養生術       方方三三
易筋經「梵」    圈方方三方方圈圈圈
金剛護體神功    三三三方方方圈圈圈
城鎮心法
蓮花落              圈圈三方
擒龍伏虎功       三方圈圈
武當純陽功       方三圈方三圈
無跡心訣           方三圈圈三方
武當太和功       方圈三圈三圈方
紫霞劍氣           三圈方方圈三
紫薇七星訣        圈圈圈三方圈
轉星換斗神功    圈圈三圈方圈
特殊心法
混元先天功*     增加經脈格(生命力)到186以及穴位x12格
真法圈三方圈方三  方三圈方圈三  三方圈三圈方

</pre>

<script>

list = [
    '404303', // 金針度穴功
    '03430', // 解蠱訣
    '443343', // 爐火鍛體術
    '430034', // 無跡心訣
    '43044', // 洗隨功
    '333444000', // 金剛護體神功
    '043033', // 醉仙訣
    '44303', // 避毒訣
    '304403', // 紫霞劍氣
    '300443', // 玄火劫心功
    '444000', // 地藏伏魔勁
    '344043', // 清心訣
    '03344', // 偷天換日功
    '443', // 灼心訣
    '043', // 寒冰訣
    '34343', // 搬血鍛體訣
    '000304', // 華嚴地藏經
    '043404', // 化龍功
    '043003', // 五覺功
]

function findBestWithinMax(list, max) {
    let latest = ""
    let supported = []
    
    for (let i = 0; i < list.length; i++) {
        let shortest = shortestSuperstring([...supported, list[i]])
        if (shortest.length <= max) {
            latest = shortest
            supported.push(list[i])
        }
    }
    
    return {
        shortest: latest,
        length: latest.length,
        supported
    }
}

function findShortest(list) {
    return findShortestHelper("", list)
}

function findShortestHelper(current, remainingList) {
    if (remainingList.length == 0) {
        return current
    }
    
    let shortest = null
    let winner = null
    
    remainingList.forEach((item, i) => {
        let short = findShortestHelper(
            shortestMerge(current, item),
            [
                ...remainingList.slice(0, i),
                ...remainingList.slice(i+1)
            ]
        )
        
        if (shortest == null || short.length < shortest.length) {
            shortest = short
            winner = i
        }
    })
    
    return shortest
}

function shortestMerge(str1, str2) {
    let p1 = 0 
    let p2 = 0
    
    let save1 = 0
    
    while (p1 < str1.length && p2 < str2.length) {
        if (str1.charAt(p1) == str2.charAt(p2)) {
            p1++
            p2++
            save1++
        } else if (p2 == 0) {
            p1++
        } else {
            p2 = 0
            save1 = 0
        }
    }
    
    p1 = 0 
    p2 = 0
    let save2 = 0
    
    while (p2 < str2.length && p1 < str1.length) {
        if (str2.charAt(p2) == str1.charAt(p1)) {
            p2++
            p1++
            save2++
        } else if (p1 == 0) {
            p2++
        } else {
            p1 = 0
            save2 = 0
        }
    }
    
    if (save1 < save2) {
        if (save2 >= str1.length) {
            return str2
        }
        return str2.substring(0, str2.length - save2) + str1
    }
    
    if (save1 >= str2.length) {
        return str1
    }
    return str1.substring(0, str1.length - save1) + str2
}

// leetcode
function shortestSuperstring(words) {
    const n = words.length;
    
    // Step 1: Calculate the overlap between each pair of words
    const overlap = Array.from({ length: n }, () => Array(n).fill(0));
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (i !== j) {
                overlap[i][j] = getOverlap(words[i], words[j]);
            }
        }
    }

    // Step 2: Initialize DP and parent tables
    const dp = Array.from({ length: 1 << n }, () => Array(n).fill(Infinity));
    const parent = Array.from({ length: 1 << n }, () => Array(n).fill(-1));

    for (let i = 0; i < n; i++) {
        dp[1 << i][i] = words[i].length;
    }

    // Step 3: Fill DP table using bitmasking
    for (let mask = 1; mask < (1 << n); mask++) {
        for (let i = 0; i < n; i++) {
            if ((mask & (1 << i)) === 0) continue;  // skip if word `i` is not in the mask
            const prevMask = mask ^ (1 << i);  // remove the current word from mask
            for (let j = 0; j < n; j++) {
                if ((prevMask & (1 << j)) === 0) continue;  // skip if word `j` is not in the mask
                const newLength = dp[prevMask][j] + overlap[j][i];
                if (newLength < dp[mask][i]) {
                    dp[mask][i] = newLength;
                    parent[mask][i] = j;
                }
            }
        }
    }

    // Step 4: Find the minimum length superstring
    let lastWord = -1;
    let minLength = Infinity;
    const finalMask = (1 << n) - 1;

    for (let i = 0; i < n; i++) {
        if (dp[finalMask][i] < minLength) {
            minLength = dp[finalMask][i];
            lastWord = i;
        }
    }

    // Step 5: Reconstruct the shortest superstring
    let mask = finalMask;
    const sequence = [];

    while (mask > 0) {
        sequence.push(lastWord);
        const prev = lastWord;
        lastWord = parent[mask][lastWord];
        mask ^= (1 << prev);  // remove the last word from the mask
    }

    sequence.reverse();  // reverse the sequence to get the correct order

    // Step 6: Build the superstring using the sequence and overlaps
    let result = words[sequence[0]];
    for (let i = 1; i < sequence.length; i++) {
        const overlapLen = overlap[sequence[i - 1]][sequence[i]];
        result += words[sequence[i]].substring(words[sequence[i]].length - overlapLen);
    }

    return result;
}

// Helper function to calculate the overlap between two words
function getOverlap(a, b) {
    for (let len = Math.min(a.length, b.length); len > 0; len--) {
        if (a.endsWith(b.substring(0, len))) {
            return b.length - len;
        }
    }
    return b.length;
}

// console.log(shortestMerge('1234', '4321'))

// console.log(shortestSuperstring(list))

console.log(findBestWithinMax(list, 30))

</script>